use std::collections::HashMap;

use crate::{error::{BNFCompileError, ParseError}, state_machine::{self, ASTNode, MatchRecord, StateMachineParser, State, StateAction}, Token, TokenType};

pub type RuleId = usize;

#[derive(Debug)]
pub enum BNFDescription<TT, R> {
    Token(TT),
    ChoiceStart,
    ChoiceDivide,
    ChoiceEnd,
    OptionStart,
    OptionEnd,
    RepetitionStart,
    RepetitionEnd,
    Rule(R),
}

pub struct BNFRule<TT> {
    pub id: RuleId,
    pub description: Vec<BNFDescription<TT, RuleId>>,
}

pub type StateId = i32;

pub struct StateManager<TT> where TT: TokenType {
    pub states: Vec<State<TT>>,
    pub placeholders: Vec<State<TT>>,
    pub start_states: HashMap<RuleId, StateId>,
    pub rule_ids: HashMap<Vec<char>, RuleId>,
    pub rule_names: HashMap<RuleId, String>,
}
impl<TT> StateManager<TT> where TT: TokenType {
    fn new(rule_ids: HashMap<Vec<char>, RuleId>, rule_names: HashMap<RuleId, String>) -> Self {
        let mut manager = Self { states: Vec::new(), placeholders: Vec::new(), start_states: HashMap::new(), rule_ids, rule_names, };
        manager.new_placeholder(); // The first placeholder id is 0, which conflict to states id
        manager
    }
    fn state_mut(&mut self, id: StateId) -> &mut State<TT> {
        if id >= 0 {
            &mut self.states[id as usize]
        } else {
            &mut self.placeholders[(-id) as usize]
        }
    }
    fn new_state(&mut self, rule: RuleId) -> StateId {
        let id = self.states.len() as StateId;
        self.states.push(State { id, rule, actions: Vec::new() });
        return id;
    }
    fn new_placeholder(&mut self) -> StateId {
        let id = -(self.placeholders.len() as StateId);
        self.placeholders.push(State { id, rule: 0, actions: Vec::new() });
        return id;
    }
    fn replace_placeholder(&mut self, placeholder: StateId, state: StateId) {
        let placeholder = &self.placeholders[(-placeholder) as usize];
        let state = &mut self.states[state as usize];
        for action in &placeholder.actions {
            match action {
                StateAction::Call(sub_rule, end_state) => state.actions.push(StateAction::Call(*sub_rule, *end_state)),
                StateAction::End => if !state.actions.contains(&StateAction::End) {state.actions.push(StateAction::End)},
                StateAction::MatchToken(all_next_states) => {
                    for (condition, next_states) in all_next_states {
                        for next_state in next_states {
                            state.add_next_state(condition.clone(), *next_state)
                        }
                    }
                },
                StateAction::MatchExcept(..) => panic!(), // Only for special case, it won't be automatically generated by rule compiler.
            }
        }
    }
    /* fn write_file(states: &Vec<State<TT>>) -> std::io::Result<()> {
        let mut file = std::fs::File::create("states.txt")?;
        for state in states {
            writeln!(file, "{}", state)?
        }
        Ok(())
    } */
    pub fn print_states(&self) {

        /* if let Err(e) = write_file(&self.states) {
            println!("{}", e);
        } */
    }
    fn compile_rule(&mut self, rule: &BNFRule<TT>) {
        let mut state_records: Vec<(Vec<StateId>, Vec<StateId>)> = Vec::new();
        let start_state = self.new_state(rule.id);
        self.start_states.insert(rule.id, start_state);
        let mut last_states: Vec<StateId> = vec![start_state];
        for d in &rule.description {
            match d {
                BNFDescription::Token(token_type) => {
                    let new_state = self.new_state(rule.id);
                    for ls in &last_states {
                        self.state_mut(*ls).add_next_state(token_type.clone(), new_state);
                    }
                    last_states.clear();
                    last_states.push(new_state);
                },
                BNFDescription::ChoiceStart => state_records.push((last_states.clone(), Vec::new())),
                BNFDescription::ChoiceDivide => {
                    let (choice_start_states, choice_end_states) = state_records.last_mut().unwrap();
                    choice_end_states.append(&mut last_states);
                    last_states = choice_start_states.clone();
                },
                BNFDescription::ChoiceEnd => {
                    let (_, mut choice_end_states) = state_records.pop().unwrap();
                    last_states.append(&mut choice_end_states);
                },
                BNFDescription::OptionStart => state_records.push((last_states.clone(), Vec::new())),
                BNFDescription::OptionEnd => {
                    let (mut option_start_states, _) = state_records.pop().unwrap();
                    last_states.append(&mut option_start_states);
                },
                BNFDescription::RepetitionStart => {
                    let placeholder = self.new_placeholder();
                    state_records.push((last_states.clone(), vec![placeholder]));
                    last_states.push(placeholder);
                },
                BNFDescription::RepetitionEnd => {
                    let (mut repetition_start_states, placeholder) = state_records.pop().unwrap();
                    for last_state in &last_states {
                        self.replace_placeholder(placeholder[0], *last_state);
                    }
                    last_states.append(&mut repetition_start_states);
                },
                BNFDescription::Rule(identifier) => {
                    let new_state = self.new_state(rule.id);
                    for ls in &last_states {
                        self.state_mut(*ls).add_rule(*identifier, new_state);
                    }
                    last_states.clear();
                    last_states.push(new_state);
                },
            }
        }
        for last_state in &last_states {
            self.state_mut(*last_state).actions.push(StateAction::End);
        }
    }
}

impl TokenType for char {}

impl Token<char> for char {
    fn token_type(&self) -> &char {
        self
    }
}

pub fn compile_bnf_rules<S, TT>(rules_string: S) -> Result<StateManager<TT>, BNFCompileError>
where S: ToString, TT: TokenType + TryFrom<Vec<char>> {
    const IDENTIFIER: RuleId = 0; // Identifier = <any except "=(|)[]{};">{<any except "=(|)[]{};">}
    const BNF_RULE: RuleId = 1; // BNFRule = Identifier{space_char}"="{(Identifier | "(|)[]{}" | space_char)} ";";
    const BNF_RULES: RuleId = 2; // BNFRules = {BNFRule|space_char};
    const NON_IDENTIFIER_CHARS: &str = "=(|)[]{};\u{0009}\u{000A}\u{000B}\u{000C}\u{000D}\u{0020}\u{0085}\u{200E}\u{200F}\u{2028}\u{2029}";
    let bnf_rules_state_manager: StateManager<char> = StateManager {
        states: vec![
            State { id: 0, rule: IDENTIFIER, actions: vec![StateAction::MatchExcept(NON_IDENTIFIER_CHARS.chars().collect::<Vec<char>>(), vec![1])]},
            State { id: 1, rule: IDENTIFIER, actions: vec![StateAction::MatchExcept(NON_IDENTIFIER_CHARS.chars().collect::<Vec<char>>(), vec![1]), StateAction::End]},
            State { id: 2, rule: BNF_RULE, actions: vec![StateAction::Call(IDENTIFIER, 3)]},
            State { id: 3, rule: BNF_RULE, actions: vec![
                StateAction::MatchToken(HashMap::from([
                    ('\u{0009}', vec![3]),
                    ('\u{000A}', vec![3]),
                    ('\u{000B}', vec![3]),
                    ('\u{000C}', vec![3]),
                    ('\u{000D}', vec![3]),
                    ('\u{0020}', vec![3]),
                    ('\u{0085}', vec![3]),
                    ('\u{200E}', vec![3]),
                    ('\u{200F}', vec![3]),
                    ('\u{2028}', vec![3]),
                    ('\u{2029}', vec![3]),
                    ('=', vec![4]),
                ]))
            ]},
            State { id: 4, rule: BNF_RULE, actions: vec![
                StateAction::Call(IDENTIFIER, 4),
                StateAction::MatchToken(HashMap::from([
                    ('\u{0009}', vec![4]),
                    ('\u{000A}', vec![4]),
                    ('\u{000B}', vec![4]),
                    ('\u{000C}', vec![4]),
                    ('\u{000D}', vec![4]),
                    ('\u{0020}', vec![4]),
                    ('\u{0085}', vec![4]),
                    ('\u{200E}', vec![4]),
                    ('\u{200F}', vec![4]),
                    ('\u{2028}', vec![4]),
                    ('\u{2029}', vec![4]),
                    ('(', vec![4]),
                    ('|', vec![4]),
                    (')', vec![4]),
                    ('[', vec![4]),
                    (']', vec![4]),
                    ('{', vec![4]),
                    ('}', vec![4]),
                    (';', vec![5]),
                ]))
            ]},
            State { id: 5, rule: BNF_RULE, actions: vec![StateAction::End]},
            State { id: 6, rule: BNF_RULES, actions: vec![
                StateAction::Call(BNF_RULE, 6),
                StateAction::MatchToken(HashMap::from([
                    ('\u{0009}', vec![6]),
                    ('\u{000A}', vec![6]),
                    ('\u{000B}', vec![6]),
                    ('\u{000C}', vec![6]),
                    ('\u{000D}', vec![6]),
                    ('\u{0020}', vec![6]),
                    ('\u{0085}', vec![6]),
                    ('\u{200E}', vec![6]),
                    ('\u{200F}', vec![6]),
                    ('\u{2028}', vec![6]),
                    ('\u{2029}', vec![6]),
                ])),
                StateAction::End
            ]},
        ],
        placeholders: Vec::new(),
        start_states: HashMap::from([(IDENTIFIER, 0), (BNF_RULE, 2), (BNF_RULES, 6)]),
        rule_ids: HashMap::new(),
        rule_names: HashMap::new(),
    };
    let rules_tokens = rules_string.to_string().chars().collect::<Vec<char>>();
    let mut bnf_rules_parser = StateMachineParser::new(&bnf_rules_state_manager);
    let match_records = match bnf_rules_parser.parse(&rules_tokens, BNF_RULES) {
        Ok(m) => m,
        Err(e) => return Err(BNFCompileError::ParseError(e)),
    };
    /* let rule_names = HashMap::from([
        (IDENTIFIER, "IDENTIFIER"),
        (BNF_RULE, "BNF_RULE"),
        (BNF_RULES, "BNF_RULES"),
    ]);
    state_machine::debug_print_match_record(&rules_tokens, &match_records, &rule_names);
    return Err(BNFCompileError::UnknownError); */
    let mut ast_node: ASTNode = ASTNode::from(&match_records);
    let mut rules_data: Vec<(Vec<char>, Vec<BNFDescription<TT, Vec<char>>>)> = Vec::new();
    let mut rule_ids: HashMap<Vec<char>, RuleId> = HashMap::new();
    let mut rule_names: HashMap<RuleId, String> = HashMap::new();
    for rule in &mut ast_node.sub_nodes {
        if rule.sub_nodes.is_empty() && rules_tokens[rule.token_index].is_whitespace() {
            continue;
        }
        let mut state = 0;
        for sub_node in &rule.sub_nodes {
            if sub_node.sub_nodes.is_empty() && rules_tokens[sub_node.token_index].is_whitespace() {
                continue;
            }
            match state {
                0 => if sub_node.rule == IDENTIFIER {
                    let rule_name = sub_node.sub_nodes.iter().map(|c| rules_tokens[c.token_index]).collect::<Vec<char>>();
                    rule_ids.insert(rule_name.clone(), rules_data.len());
                    rule_names.insert(rules_data.len(), rule_name.iter().collect::<String>());
                    rules_data.push((rule_name, Vec::new()));
                    state += 1;
                },
                1 => if sub_node.sub_nodes.is_empty() && rules_tokens[sub_node.token_index] == '=' {
                    state += 1;
                }
                2 => if sub_node.sub_nodes.is_empty() && rules_tokens[sub_node.token_index] == ';' {
                    break;
                } else {
                    let d = if sub_node.sub_nodes.is_empty() {
                        match rules_tokens[sub_node.token_index] {
                            '(' => BNFDescription::ChoiceStart,
                            '|' => BNFDescription::ChoiceDivide,
                            ')' => BNFDescription::ChoiceEnd,
                            '[' => BNFDescription::OptionStart,
                            ']' => BNFDescription::OptionEnd,
                            '{' => BNFDescription::RepetitionStart,
                            '}' => BNFDescription::RepetitionEnd,
                            _ => return Err(BNFCompileError::UnknownError),
                        }
                    } else {
                        BNFDescription::Rule(sub_node.sub_nodes.iter().map(|c| rules_tokens[c.token_index]).collect::<Vec<char>>())
                    };
                    rules_data.last_mut().unwrap().1.push(d);
                }
                _ => return Err(BNFCompileError::UnknownError),
            }
        }
    }
    let mut rules: Vec<BNFRule<TT>> = Vec::with_capacity(rules_data.len());
    for (rule_name, description_data) in rules_data {
        let mut description = Vec::with_capacity(description_data.len());
        for d in description_data {
            description.push(match d {
                BNFDescription::Token(_) => return Err(BNFCompileError::UnexpectedToken),
                BNFDescription::ChoiceStart => BNFDescription::ChoiceStart,
                BNFDescription::ChoiceDivide => BNFDescription::ChoiceDivide,
                BNFDescription::ChoiceEnd => BNFDescription::ChoiceEnd,
                BNFDescription::OptionStart => BNFDescription::OptionStart,
                BNFDescription::OptionEnd => BNFDescription::OptionEnd,
                BNFDescription::RepetitionStart => BNFDescription::RepetitionStart,
                BNFDescription::RepetitionEnd => BNFDescription::RepetitionEnd,
                BNFDescription::Rule(identifier) => match rule_ids.get(&identifier) {
                    Some(rule_id) => BNFDescription::Rule(*rule_id),
                    None => match TT::try_from(identifier) {
                        Ok(t) => BNFDescription::Token(t),
                        Err(_) => return Err(BNFCompileError::UndefinedTokenIdentifier),
                    }
                },
            })
        }
        rules.push(BNFRule { id: *rule_ids.get(&rule_name).unwrap(), description });
    }
    let mut state_manager = StateManager::new(rule_ids, rule_names);
    for rule in &rules {
        state_manager.compile_rule(rule);
    };
    Ok(state_manager)
}
