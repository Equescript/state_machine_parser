use std::{collections::HashMap, marker::PhantomData};
use crate::{bnf_rules_compiler::{RuleId, StateId, StateManager}, error::ParseError, Token, TokenType};

impl<TT> StateManager<TT> where TT: TokenType {
    fn state(&self, id: StateId) -> Result<&State<TT>, ParseError> {
        if id >= 0 {
            match self.states.get(id as usize) {
                Some(state) => Ok(state),
                None => Err(ParseError::UnexpectedState(id))
            }
        } else {
            Err(ParseError::UnexpectedState(id))
        }
    }
    fn rule_start_state(&self, rule: &RuleId) -> Result<StateId, ParseError> {
        match self.start_states.get(rule) {
            Some(start_state) => Ok(*start_state),
            None => {
                println!("Cannot find rule start state of {:?}!", rule);
                Err(ParseError::UnexpectedRule(*rule))
            }
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum StateAction<TT> where TT: TokenType {
    Call(RuleId, StateId),
    End,
    MatchToken(HashMap<TT, Vec<StateId>>),
    MatchExcept(Vec<TT>, Vec<StateId>), // Only for special case, it won't be automatically generated by rule compiler.
}

pub struct State<TT> where TT: TokenType {
    pub id: StateId,
    pub rule: RuleId,
    pub actions: Vec<StateAction<TT>>,
}
impl<TT> State<TT> where TT: TokenType {
    pub fn add_next_state(&mut self, condition: TT, next_state: StateId) {
        for action in &mut self.actions {
            if let StateAction::MatchToken(next_states) = action {
                match next_states.get_mut(&condition) {
                    Some(next_states) => if !next_states.contains(&next_state) {next_states.push(next_state)},
                    None => {next_states.insert(condition, vec![next_state]);},
                }
                return;
            }
        }
        self.actions.push(StateAction::MatchToken(HashMap::from([(condition, vec![next_state])])));
    }
    pub fn add_rule(&mut self, rule: RuleId, end_state: StateId) {
        self.actions.push(StateAction::Call(rule, end_state))
    }
}

#[derive(Debug)]
struct TracebackRecord {
    token_index: usize,
    state: StateId,
    action_index: usize,
    next_state_index: usize,
    match_record_length: usize,
}
type StateMachineContext<'t, 'm, T> = (RuleId, &'t Vec<T>, &'m mut Vec<TracebackRecord>, &'m mut Vec<StateId>, &'m mut Vec<MatchRecord>);
pub struct StateMachineParser<'m, TT> where /* T: Token<TT>,  */TT: TokenType {
    // start_rule: RuleId,
    state_manager: &'m StateManager<TT>,
    // tokens : &'t Vec<T>,

    current_state: StateId,

    // traceback_record: Vec<TracebackRecord>,
    // rule_call_record: Vec<StateId>,
    // match_record: Vec<MatchRecord>,
}
impl<'m, TT> StateMachineParser<'m, TT> where TT: TokenType {
    pub fn new(state_manager: &'m StateManager<TT>) -> Self {
        // Self { start_rule, state_manager, current_state: state_manager.rule_start_state(&start_rule), match_record: vec![MatchRecord::RuleStart(start_rule)], rule_call_record: Vec::new(), traceback_record: Vec::new() }
        Self { state_manager, current_state: -1 }
    }
    fn next_action_of_current_state<T>(&self, context: StateMachineContext<T>, token_index: usize, action_index: usize, next_state_index: usize) -> Result<Option<(usize, usize)>, ParseError> where T: Token<TT> {
        let (start_rule, tokens, traceback_records, rule_call_record, match_record) = context;
        let current_state = self.state_manager.state(self.current_state)?;
        macro_rules! NextAction { () => { if action_index+1 < current_state.actions.len() { Some((action_index+1, 0)) } else { None } }; }
        let next_action = match &current_state.actions[action_index] {
            StateAction::MatchToken(next_states) => match next_states.get(
                match tokens.get(token_index) {
                    Some(token) => token.token_type(),
                    None => return Ok(NextAction!())
                }
            ) {
                Some(next_states) => if next_state_index+1 < next_states.len() {
                    Some((action_index, next_state_index+1))
                } else {
                    NextAction!()
                },
                None => NextAction!()
            }
            _ => NextAction!()
        };
        Ok(next_action)
    }
    fn traceback<T>(&mut self, context: StateMachineContext<T>) -> Result<Option<(usize, usize, usize)>, ParseError> where T: Token<TT> {
        let (start_rule, tokens, traceback_records, rule_call_records, match_records) = context;
        loop {
            let traceback_record = match traceback_records.pop() {
                Some(traceback_record) => traceback_record,
                None => return Ok(None)
            };
            // let traceback_record = Ok(traceback_records.pop())?;
            // println!("traceback_record.pop(): {:?}", traceback_record);
            while match_records.len() > traceback_record.match_record_length {
                match match_records.pop().unwrap() {
                    MatchRecord::RuleStart(_) => {rule_call_records.pop();},
                    MatchRecord::RuleEnd(_, end_state) => rule_call_records.push(end_state),
                    _ => (),
                }
            }
            self.current_state = traceback_record.state;
            match self.next_action_of_current_state((start_rule, tokens, traceback_records, rule_call_records, match_records), traceback_record.token_index, traceback_record.action_index, traceback_record.next_state_index)? {
                Some((action_index, next_state_index)) => return Ok(Some((traceback_record.token_index, action_index, next_state_index))),
                None => continue,
            }
        }
    }
    fn perform_action<T>(&mut self, context: StateMachineContext<T>,
        token_index: usize, action_index: usize, next_state_index: usize) -> Result<Option<Result<usize, ()>>, ParseError> where T: Token<TT> {
        let (start_rule, tokens, traceback_records, rule_call_records, match_records) = context;
        let current_state = self.state_manager.state(self.current_state)?;
        let (result, mut available_actions_number) = match &current_state.actions[action_index] {
            StateAction::Call(sub_rule, end_state) => {
                rule_call_records.push(*end_state);
                (Ok((0, self.state_manager.rule_start_state(sub_rule)?, MatchRecord::RuleStart(*sub_rule))), 0)
            },
            StateAction::End => {
                match rule_call_records.pop() {
                    Some(end_state) => (Ok((0, end_state, MatchRecord::RuleEnd(current_state.rule, end_state))), 0),
                    None => if token_index >= tokens.len() { return Ok(None); } else { (Err(()), 0) } // End of root rule
                }
            },
            StateAction::MatchToken(all_next_states) => match tokens.get(token_index) {
                Some(token) => match all_next_states.get(token.token_type()) {
                    Some(next_states) => (Ok((1, next_states[next_state_index], MatchRecord::Token(token_index))), next_states.len() - next_state_index - 1),
                    None => (Err(()), 0),
                },
                None => (Err(()), 0), // last token has been matched
            },
            StateAction::MatchExcept(exceptions, next_states) => match tokens.get(token_index) {
                Some(token) => if exceptions.contains(token.token_type()) {
                    (Err(()), 0)
                } else {
                    (Ok((1, next_states[next_state_index], MatchRecord::Token(token_index))), next_states.len() - next_state_index - 1)
                }
                None => (Err(()), 0), // last token has been matched
            },
        };
        for action in &current_state.actions[action_index+1..] {
            available_actions_number += match action {
                StateAction::Call(..) => 1,
                StateAction::End => 1,
                StateAction::MatchToken(next_states) => match tokens.get(token_index) {
                    Some(token) => match next_states.get(token.token_type()) {
                        Some(next_states) => next_states.len(),
                        None => 0,
                    }
                    None => 0,
                }
                StateAction::MatchExcept(exceptions, next_states) => match tokens.get(token_index) {
                    Some(token) => if exceptions.contains(token.token_type()) {
                        0
                    } else {
                        next_states.len()
                    }
                    None => 0,
                },
            }
        }
        if available_actions_number > 0 {
            let traceback_record = TracebackRecord { token_index, state: self.current_state, action_index, next_state_index, match_record_length: match_records.len() };
            // println!("traceback_record.push(): {:?}", traceback_record);
            traceback_records.push(traceback_record);
        }
        if let Ok((step, next_state, match_record)) = result {
            // match self.tokens.get(token_index) {
                // Some(token) => println!("({:?} {}) [{}: {}] {:?} -> ({:?} {})", current_state.rule, self.current_state, token_index, token, current_state.actions[action_index], self.state_manager.state(next_state).rule, next_state),
                // None => println!("({:?} {}) [{}: {}] {:?} -> ({:?} {})", current_state.rule, self.current_state, token_index, "Out of Bounds", current_state.actions[action_index], self.state_manager.state(next_state).rule, next_state),
            // }
            // self.debug_print();
            match_records.push(match_record);
            self.current_state = next_state;
            Ok(Some(Ok(step)))
        } else {
            Ok(Some(Err(())))
        }
    }
    fn match_tokens<T>(&mut self, context: StateMachineContext<T>) -> Result<(), ParseError> where T: Token<TT> {
        let (start_rule, tokens, traceback_records, rule_call_records, match_records) = context;
        let mut token_index = 0;
        let mut max_token_index = 0;
        let (mut action_index, mut next_state_index) = (0, 0);
        loop {
            if token_index > max_token_index {
                max_token_index = token_index;
            }
            match self.perform_action((start_rule, tokens, traceback_records, rule_call_records, match_records), token_index, action_index, next_state_index)? {
                Some(result) =>
                    match result {
                        Ok(step) => { // Step forward. The step is 1 if it match any token, otherwise step will be 0.
                            token_index += step;
                            (action_index, next_state_index) = (0, 0);
                        },
                        Err(()) => { // Match Error. We need traceback.
                            (token_index, action_index, next_state_index) = match self.traceback((start_rule, tokens, traceback_records, rule_call_records, match_records))? {
                                Some(traceback_record) => traceback_record,
                                None => return Err(ParseError::UnexpectedToken(max_token_index)), // Can't find more traceback point, which means we meet unexpected token.
                            }
                        },
                    }
                None => return Ok(()), // Match End
            }
        }
    }
    pub fn parse<T>(&mut self, tokens: &Vec<T>, start_rule: RuleId) -> Result<Vec<MatchRecord>, ParseError> where T: Token<TT> {
        let mut traceback_records: Vec<TracebackRecord> = Vec::new();
        let mut rule_call_records: Vec<StateId> = Vec::new();
        let mut match_records: Vec<MatchRecord> = vec![MatchRecord::RuleStart(start_rule)];
        self.current_state = self.state_manager.rule_start_state(&start_rule)?;
        self.match_tokens((start_rule, tokens, &mut traceback_records, &mut rule_call_records, &mut match_records))?;
        match_records.push(MatchRecord::RuleEnd(start_rule, -1));
        Ok(match_records)
    }
    pub fn end_print(&self) {
        println!("--------------------------------------------------");
        // self.debug_print();
        // let start_state = self.state_manager.state(self.state_manager.rule_start_state(&RuleId::leaf_expression));
        // println!("{:?} {} {:?}", start_state.rule, start_state.id, start_state.actions)
    }
    /* pub fn debug_print(&self) {
        let mut indent = -1;
        let mut last_is_rule = false;
        for record in &self.match_record {
            match record {
                MatchRecord::RuleStart(..) => {
                    if last_is_rule { print!("{{") } else {
                        for _ in 0..indent { print!("\t"); }
                        print!("{}\n", record);
                    }
                    indent += 1;
                    // last_is_rule = true;
                },
                MatchRecord::RuleEnd(..) => {
                    indent -= 1;
                    if last_is_rule { print!("}}") } else {
                        for _ in 0..indent { print!("\t"); }
                        print!("{}\n", record);
                    }
                    // last_is_rule = true;
                },
                MatchRecord::Token(..) => {
                    for _ in 0..indent { print!("\t"); }
                    print!("{}\n", record);
                    // last_is_rule = false;
                },
            }
        }
        // println!("self.current_states.len() = {}", self.current_states.len())
    } */
}

pub fn debug_print_match_record<T, TT, S>(tokens: &Vec<T>, match_records: &Vec<MatchRecord>, rule_names: &HashMap<RuleId, S>)
where T: Token<TT> + std::fmt::Display, TT: TokenType, S: std::fmt::Display {
    print!(" ");
    let mut counter = 0;
    fn align(n: usize) {
        for _ in 0..n {
            print!("\t");
        }
    }
    for match_record in match_records {
        match match_record {
            MatchRecord::Token(token_index) => {
                align(counter);
                print!("{}\n", tokens[*token_index])
            },
            MatchRecord::RuleStart(rule) => {
                align(counter);
                counter += 1;
                print!("{{ {}\n", rule_names.get(rule).unwrap());
            },
            MatchRecord::RuleEnd(rule, _) => {
                counter = counter.saturating_sub(1);
                align(counter);
                print!("}} {}\n", rule_names.get(rule).unwrap());
            },
        }
    }
}

#[derive(Clone, Debug)]
pub enum MatchRecord {
    Token(usize),
    RuleStart(RuleId),
    RuleEnd(RuleId, StateId),
}

#[derive(Debug)]
pub struct ASTNode {
    pub rule: RuleId,
    pub token_index: usize,
    pub sub_nodes: Vec<ASTNode>,
}

impl From<&Vec<MatchRecord>> for ASTNode {
    fn from(value: &Vec<MatchRecord>) -> Self {
        let mut nodes: Vec<ASTNode> = vec![ASTNode { rule: 0, token_index: 0, sub_nodes: Vec::new() }];
        for r in value {
            match r {
                MatchRecord::Token(token_index) => {
                    let new_token = ASTNode { rule: nodes.last().unwrap().rule, token_index: *token_index, sub_nodes: Vec::new() };
                    nodes.last_mut().unwrap().sub_nodes.push(new_token);
                },
                MatchRecord::RuleStart(rule) => {
                    nodes.push(ASTNode { rule: *rule, token_index: 0, sub_nodes: Vec::new() })
                },
                MatchRecord::RuleEnd(_, _) => {
                    let ast_node = nodes.pop().unwrap();
                    nodes.last_mut().unwrap().sub_nodes.push(ast_node);
                },
            }
        }
        nodes[0].sub_nodes.pop().unwrap()
    }
}
impl From<Vec<MatchRecord>> for ASTNode {
    fn from(value: Vec<MatchRecord>) -> Self {
        <ASTNode as From<&Vec<MatchRecord>>>::from(&value)
    }
}
